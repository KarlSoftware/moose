/****************************************************************/
/*               DO NOT MODIFY THIS HEADER                      */
/* MOOSE - Multiphysics Object Oriented Simulation Environment  */
/*                                                              */
/*           (c) 2010 Battelle Energy Alliance, LLC             */
/*                   ALL RIGHTS RESERVED                        */
/*                                                              */
/*          Prepared by Battelle Energy Alliance, LLC           */
/*            Under Contract No. DE-AC07-05ID14517              */
/*            With the U. S. Department of Energy               */
/*                                                              */
/*            See COPYRIGHT for full restrictions               */
/****************************************************************/

#include "MultiAppNearestNodeTransfer.h"

// Moose
#include "MooseTypes.h"
#include "FEProblem.h"
#include "DisplacedProblem.h"

// libMesh
#include "libmesh/system.h"
#include "libmesh/mesh_tools.h"
#include "libmesh/id_types.h"
#include "libmesh/parallel_algebra.h"

template<>
InputParameters validParams<MultiAppNearestNodeTransfer>()
{
  InputParameters params = validParams<MultiAppTransfer>();

  params.addRequiredParam<AuxVariableName>("variable", "The auxiliary variable to store the transferred values in.");
  params.addRequiredParam<VariableName>("source_variable", "The variable to transfer from.");
  params.addParam<BoundaryName>("source_boundary", "The boundary we are transferring from (if not specified, whole domain is used).");
/*
  params.addParam<bool>("displaced_source_mesh", false, "Whether or not to use the displaced mesh for the source mesh.");
  params.addParam<bool>("displaced_target_mesh", false, "Whether or not to use the displaced mesh for the target mesh.");
*/
  params.addParam<bool>("fixed_meshes", false, "Set to true when the meshes are not changing (ie, no movement or adaptivity).  This will cache nearest node neighbors to greatly speed up the transfer.");

  return params;
}

MultiAppNearestNodeTransfer::MultiAppNearestNodeTransfer(const std::string & name, InputParameters parameters) :
    MultiAppTransfer(name, parameters),
    _to_var_name(getParam<AuxVariableName>("variable")),
    _from_var_name(getParam<VariableName>("source_variable")),
/*
    _displaced_source_mesh(getParam<bool>("displaced_source_mesh")),
    _displaced_target_mesh(getParam<bool>("displaced_target_mesh")),
*/
    _fixed_meshes(getParam<bool>("fixed_meshes"))
{
  // This transfer does not work with ParallelMesh
  //_fe_problem.mesh().errorIfParallelDistribution("MultiAppNearestNodeTransfer");
}

void
MultiAppNearestNodeTransfer::initialSetup()
{
  if (_direction == TO_MULTIAPP)
    variableIntegrityCheck(_to_var_name);
  else
    variableIntegrityCheck(_from_var_name);
}

void
MultiAppNearestNodeTransfer::transferToMultiApp()
{
  std::vector<MeshTools::BoundingBox> bboxes = getBboxes();
  mooseAssert(bboxes.size() == n_processors(), "MultiAppNearestNodeTransfer did not get one bounding box per processor");

  FEProblem & from_problem = *_from_problems[0];

  if (_displaced_source_mesh && from_problem.getDisplacedProblem())
    mooseError("Cannot use a NearestNode transfer from a displaced mesh to a MultiApp!");

  MooseMesh * from_mesh = &from_problem.mesh();
  MooseVariable & from_var = from_problem.getVariable(0, _from_var_name);
  SystemBase & from_system_base = from_var.sys();

  System & from_sys = from_system_base.system();
  unsigned int from_sys_num = from_sys.number();

  // Only works with a serialized mesh to transfer from!
  //mooseAssert(from_sys.get_mesh().is_serial(), "MultiAppNearestNodeTransfer only works with SerialMesh!");

  unsigned int from_var_num = from_sys.variable_number(from_var.name());

  // EquationSystems & from_es = from_sys.get_equation_systems();

  //Create a serialized version of the solution vector
  NumericVector<Number> * serialized_solution = NumericVector<Number>::build(from_sys.comm()).release();
  serialized_solution->init(from_sys.n_dofs(), false, SERIAL);

  // Need to pull down a full copy of this vector on every processor so we can get values in parallel
  from_sys.solution->localize(*serialized_solution);

  std::vector<std::vector<Point> > outgoing_qps(n_processors());
  std::vector<std::map<std::pair<unsigned int, unsigned int>, unsigned int> > node_index_map(n_processors());
  // node_index_map[node_x.id] = index
  // outgoing_qps[index] corresponds to node_x

  for (unsigned int i_to = 0; i_to < _to_problems.size(); i_to++)
  {
    // Loop over the master nodes and set the value of the variable
    System * to_sys = find_sys(*_to_es[i_to], _to_var_name);

    unsigned int sys_num = to_sys->number();
    unsigned int var_num = to_sys->variable_number(_to_var_name);

    MeshBase * to_mesh = _to_meshes[i_to];

    bool is_nodal = to_sys->variable_type(var_num).family == LAGRANGE;

    if (is_nodal)
    {
      MeshBase::const_node_iterator node_it = to_mesh->local_nodes_begin();
      MeshBase::const_node_iterator node_end = to_mesh->local_nodes_end();

      for (; node_it != node_end; ++node_it)
      {
        Node * node = *node_it;

        // Skip this node if the variable has no dofs at it.
        if (node->n_dofs(sys_num, var_num) < 1)
          continue;

        // Find which bboxes might have the nearest node to this point.

        // TODO: finish this description.
        // The nearest node may be in a bounding box that does *not* contain the
        // point of interest, but there are some bounding boxes that we can
        // definitively say do not contain the nearest node.

        // Find the bounding box whose farthest corner is closest to the current
        // point.  Keep track of the distance between the point and the farthest
        // corner of that box.
        Real nearest_max_distance = std::numeric_limits<Real>::max();
        for (unsigned int i_from = 0; i_from < bboxes.size(); i_from++)
        {
          Real distance = bboxMaxDistance(*node, bboxes[i_from]);
          if (distance < nearest_max_distance)
            nearest_max_distance = distance;
        }

        for (unsigned int i_from = 0; i_from < bboxes.size(); i_from++)
        {
          Real distance = bboxMinDistance(*node, bboxes[i_from]);
          if (distance < nearest_max_distance || bboxes[i_from].contains_point(*node))
          //if (true)
          {
            std::pair<unsigned int, unsigned int> key(i_to, node->id());
            node_index_map[i_from][key] = outgoing_qps[i_from].size();
            outgoing_qps[i_from].push_back(*node + _positions[i_to]);
          }
        }
      }
    }
    else // Elemental
    {
      MeshBase::const_element_iterator elem_it = to_mesh->local_elements_begin();
      MeshBase::const_element_iterator elem_end = to_mesh->local_elements_end();

      for (; elem_it != elem_end; ++elem_it)
      {
        Elem * elem = *elem_it;

        Point centroid = elem->centroid();

        // Skip this element if the variable has no dofs at it.
        if (elem->n_dofs(sys_num, var_num) < 1)
          continue;

        // Find which bboxes might have the nearest node to this point.
        Real nearest_max_distance = std::numeric_limits<Real>::max();
        for (unsigned int i_from = 0; i_from < bboxes.size(); i_from++)
        {
          Real distance = bboxMaxDistance(centroid, bboxes[i_from]);
          if (distance < nearest_max_distance)
            nearest_max_distance = distance;
        }

        for (unsigned int i_from = 0; i_from < bboxes.size(); i_from++)
        {
          Real distance = bboxMinDistance(centroid, bboxes[i_from]);
          if (distance < nearest_max_distance || bboxes[i_from].contains_point(centroid))
          //if (true)
          {
            std::pair<unsigned int, unsigned int> key(i_to, elem->id());
            node_index_map[i_from][key] = outgoing_qps[i_from].size();
            outgoing_qps[i_from].push_back(centroid + _positions[i_to]);
          }
        }
      }
    }
  }

  /********************
  Request quadrature point evaluations from other processors and handle requests
  sent to this processor.
  ********************/
  //std::vector<std::vector<std::pair<Real, Real> > > incoming_evals(n_processors());
  std::vector<std::vector<Point> > incoming_evals(n_processors());
  for (processor_id_type i_proc = 0; i_proc < n_processors(); i_proc++)
  {
    if (i_proc == processor_id())
      continue;
    _communicator.send(i_proc, outgoing_qps[i_proc]);
  }

  for (processor_id_type i_proc = 0; i_proc < n_processors(); i_proc++)
  {
    std::vector<Point> incoming_qps;
    if (i_proc == processor_id())
      incoming_qps = outgoing_qps[i_proc];
    else
      _communicator.receive(i_proc, incoming_qps);

    //std::vector<Real> outgoing_evals(incoming_qps.size(), OutOfMeshValue);
    //std::vector<unsigned int> outgoing_ids(incoming_qps.size(), -1); // -1 = largest unsigned int
    std::vector<Point> outgoing_evals(incoming_qps.size());
    //std::vector<std::pair<Real, Real> > outgoing_evals(incoming_qps.size());
    for (unsigned int qp = 0; qp < incoming_qps.size(); qp++)
    {
      Point qpt = incoming_qps[qp];
      Real dist = std::numeric_limits<Real>::max();
      Node * nearest_node = getNearestNode(qpt, dist, from_mesh, true);

      // Assuming LAGRANGE!
      dof_id_type from_dof = nearest_node->dof_number(from_sys_num, from_var_num, 0);

      //outgoing_evals[qp].first = (*serialized_solution)(from_dof);
      //outgoing_evals[qp].second = dist;
      outgoing_evals[qp](0) = (*serialized_solution)(from_dof);
      outgoing_evals[qp](1) = dist;
    }

    if (i_proc == processor_id())
    {
      incoming_evals[i_proc] = outgoing_evals;
    }
    else
    {
      _communicator.send(i_proc, outgoing_evals);
    }
  }

  /********************
  Gather all of the qp evaluations, find the best one for each qp, and apply
  the evaluations.
  ********************/
  for (processor_id_type i_proc = 0; i_proc < n_processors(); i_proc++)
  {
    if (i_proc == processor_id())
      continue;

    _communicator.receive(i_proc, incoming_evals[i_proc]);
  }

  for (unsigned int i_to = 0; i_to < _to_problems.size(); i_to++)
  {
    // Loop over the master nodes and set the value of the variable
    System * to_sys = find_sys(*_to_es[i_to], _to_var_name);

    unsigned int sys_num = to_sys->number();
    unsigned int var_num = to_sys->variable_number(_to_var_name);

    NumericVector<Real> & solution = getTransferVector(i_to, _to_var_name);

    MeshBase * to_mesh = _to_meshes[i_to];

    bool is_nodal = to_sys->variable_type(var_num).family == LAGRANGE;

    if (is_nodal)
    {
      MeshBase::const_node_iterator node_it = to_mesh->local_nodes_begin();
      MeshBase::const_node_iterator node_end = to_mesh->local_nodes_end();

      for (; node_it != node_end; ++node_it)
      {
        Node * node = *node_it;

        // Skip this node if the variable has no dofs at it.
        if (node->n_dofs(sys_num, var_num) < 1)
          continue;

        Real min_dist = std::numeric_limits<Real>::max();
        Real best_val = 0;
        for (unsigned int i_from = 0; i_from < incoming_evals.size(); i_from++)
        {
          std::pair<unsigned int, unsigned int> key(i_to, node->id());
          if (node_index_map[i_from].find(key) == node_index_map[i_from].end())
            continue;
          unsigned int qp_ind = node_index_map[i_from][key];
          //if (incoming_evals[i_from][qp_ind].second >= min_dist)
          if (incoming_evals[i_from][qp_ind](1) >= min_dist)
            continue;
          //best_val = incoming_evals[i_from][qp_ind].first;
          //min_dist = incoming_evals[i_from][qp_ind].second;
          best_val = incoming_evals[i_from][qp_ind](0);
          min_dist = incoming_evals[i_from][qp_ind](1);
        }

        dof_id_type dof = node->dof_number(sys_num, var_num, 0);
        solution.set(dof, best_val);
      }
    }
    else // Elemental
    {
      MeshBase::const_element_iterator elem_it = to_mesh->local_elements_begin();
      MeshBase::const_element_iterator elem_end = to_mesh->local_elements_end();

      for (; elem_it != elem_end; ++elem_it)
      {
        Elem * elem = *elem_it;

        // Skip this element if the variable has no dofs at it.
        if (elem->n_dofs(sys_num, var_num) < 1)
          continue;

        Real min_dist = std::numeric_limits<Real>::max();
        Real best_val = 0;
        for (unsigned int i_from = 0; i_from < incoming_evals.size(); i_from++)
        {
          std::pair<unsigned int, unsigned int> key(i_to, elem->id());
          if (node_index_map[i_from].find(key) == node_index_map[i_from].end())
            continue;
          unsigned int qp_ind = node_index_map[i_from][key];
          //if (incoming_evals[i_from][qp_ind].second >= min_dist)
          if (incoming_evals[i_from][qp_ind](1) >= min_dist)
            continue;
          //best_val = incoming_evals[i_from][qp_ind].first;
          //min_dist = incoming_evals[i_from][qp_ind].second;
          best_val = incoming_evals[i_from][qp_ind](0);
          min_dist = incoming_evals[i_from][qp_ind](1);
        }

        dof_id_type dof = elem->dof_number(sys_num, var_num, 0);
        solution.set(dof, best_val);
      }
    }
  }

  delete serialized_solution;
}

void
MultiAppNearestNodeTransfer::transferFromMultiApp()
{
  FEProblem & to_problem = *_multi_app->problem();
  MooseVariable & to_var = to_problem.getVariable(0, _to_var_name);
  SystemBase & to_system_base = to_var.sys();

  System & to_sys = to_system_base.system();

  NumericVector<Real> & to_solution = *to_sys.solution;

  unsigned int to_sys_num = to_sys.number();

  // Only works with a serialized mesh to transfer to!
  mooseAssert(to_sys.get_mesh().is_serial(), "MultiAppNearestNodeTransfer only works with SerialMesh!");

  unsigned int to_var_num = to_sys.variable_number(to_var.name());

  // EquationSystems & to_es = to_sys.get_equation_systems();

  MeshBase * to_mesh = NULL;

  if (_displaced_target_mesh && to_problem.getDisplacedProblem())
    to_mesh = &to_problem.getDisplacedProblem()->mesh().getMesh();
  else
    to_mesh = &to_problem.mesh().getMesh();

  bool is_nodal = to_sys.variable_type(to_var_num).family == LAGRANGE;

  dof_id_type n_nodes = to_mesh->n_nodes();
  dof_id_type n_elems = to_mesh->n_elem();

  ///// All of the following are indexed off to_node->id() or to_elem->id() /////

  // Minimum distances from each node in the "to" mesh to a node in
  std::vector<Real> min_distances;

  // The node ids in the "from" mesh that this processor has found to be the minimum distances to the "to" nodes
  std::vector<dof_id_type> min_nodes;

  // After the call to maxloc() this will tell us which processor actually has the minimum
  std::vector<unsigned int> min_procs;

  // The global multiapp ID that this processor found had the minimum distance node in it.
  std::vector<unsigned int> min_apps;


  if (is_nodal)
  {
    min_distances.resize(n_nodes, std::numeric_limits<Real>::max());
    min_nodes.resize(n_nodes);
    min_procs.resize(n_nodes);
    min_apps.resize(n_nodes);
  }
  else
  {
    min_distances.resize(n_elems, std::numeric_limits<Real>::max());
    min_nodes.resize(n_elems);
    min_procs.resize(n_elems);
    min_apps.resize(n_elems);
  }

  for (unsigned int i=0; i<_multi_app->numGlobalApps(); i++)
  {
    if (!_multi_app->hasLocalApp(i))
      continue;

    FEProblem & from_problem = *_multi_app->appProblem(i);
    MooseVariable & from_var = from_problem.getVariable(0, _from_var_name);
    SystemBase & from_system_base = from_var.sys();

    System & from_sys = from_system_base.system();

    // Only works with a serialized mesh to transfer from!
    mooseAssert(from_sys.get_mesh().is_serial(), "MultiAppNearestNodeTransfer only works with SerialMesh!");

    // unsigned int from_var_num = from_sys.variable_number(from_var.name());

    // EquationSystems & from_es = from_sys.get_equation_systems();

    MooseMesh * from_mesh = NULL;

    if (_displaced_source_mesh && from_problem.getDisplacedProblem())
      from_mesh = &from_problem.getDisplacedProblem()->mesh();
    else
      from_mesh = &from_problem.mesh();

    MeshTools::BoundingBox app_box = MeshTools::processor_bounding_box(*from_mesh, from_mesh->getMesh().processor_id());
    Point app_position = _multi_app->position(i);

    if (is_nodal)
    {
      MeshBase::const_node_iterator to_node_it = to_mesh->nodes_begin();
      MeshBase::const_node_iterator to_node_end = to_mesh->nodes_end();

      for (; to_node_it != to_node_end; ++to_node_it)
      {
        Node * to_node = *to_node_it;
        dof_id_type to_node_id = to_node->id();

        Real current_distance = 0;

        Node * nearest_node = NULL;

        if (_fixed_meshes)
        {
          if (_node_map.find(to_node->id()) == _node_map.end())  // Haven't cached it yet
          {
            nearest_node = getNearestNode(*to_node-app_position, current_distance, from_mesh, true);
            _node_map[to_node->id()] = nearest_node;
            _distance_map[to_node->id()] = current_distance;
          }
          else
          {
            nearest_node = _node_map[to_node->id()];
            current_distance = _distance_map[to_node->id()];
          }
        }
        else
          nearest_node = getNearestNode(*to_node-app_position, current_distance, from_mesh, true);

        // TODO: Logic bug when we are using caching.  "current_distance" is set by a call to getNearestNode which is
        // skipped in that case.  We shouldn't be relying on it or stuffing it in another data structure
        if (current_distance < min_distances[to_node->id()])
        {
          min_distances[to_node_id] = current_distance;
          min_nodes[to_node_id] = nearest_node->id();
          min_apps[to_node_id] = i;
        }
      }
    }
    else // Elemental
    {
      MeshBase::const_element_iterator to_elem_it = to_mesh->elements_begin();
      MeshBase::const_element_iterator to_elem_end = to_mesh->elements_end();

      for (; to_elem_it != to_elem_end; ++to_elem_it)
      {
        Elem * to_elem = *to_elem_it;
        dof_id_type to_elem_id = to_elem->id();

        Point actual_position = to_elem->centroid()-app_position;

        Real current_distance = 0;

        Node * nearest_node = NULL;

        if (_fixed_meshes)
        {
          if (_node_map.find(to_elem->id()) == _node_map.end())  // Haven't cached it yet
          {
            nearest_node = getNearestNode(actual_position, current_distance, from_mesh, true);
            _node_map[to_elem->id()] = nearest_node;
            _distance_map[to_elem->id()] = current_distance;
          }
          else
          {
            nearest_node = _node_map[to_elem->id()];
            current_distance = _distance_map[to_elem->id()];
          }
        }
        else
          nearest_node = getNearestNode(actual_position, current_distance, from_mesh, true);

        // TODO: Logic bug when we are using caching.  "current_distance" is set by a call to getNearestNode which is
        // skipped in that case.  We shouldn't be relying on it or stuffing it in another data structure
        if (current_distance < min_distances[to_elem->id()])
        {
          min_distances[to_elem_id] = current_distance;
          min_nodes[to_elem_id] = nearest_node->id();
          min_apps[to_elem_id] = i;
        }
      }
    }
  }

/*
  // We're going to need serialized solution vectors for each app
  // We could try to only do it for the apps that have mins in them...
  // but it's tough because this is a collective operation... so that would have to be coordinated
  std::vector<NumericVector<Number> *> serialized_from_solutions(_multi_app->numGlobalApps());

  if (_multi_app->hasApp())
  {
    // Swap
    MPI_Comm swapped = Moose::swapLibMeshComm(_multi_app->comm());

    for (unsigned int i=0; i<_multi_app->numGlobalApps(); i++)
    {
      if (!_multi_app->hasLocalApp(i))
        continue;

      FEProblem & from_problem = *_multi_app->appProblem(i);
      MooseVariable & from_var = from_problem.getVariable(0, _from_var_name);
      SystemBase & from_system_base = from_var.sys();

      System & from_sys = from_system_base.system();

      //Create a serialized version of the solution vector
      serialized_from_solutions[i] = NumericVector<Number>::build().release();
      serialized_from_solutions[i]->init(from_sys.n_dofs(), false, SERIAL);

      // Need to pull down a full copy of this vector on every processor so we can get values in parallel
      from_sys.solution->localize(*serialized_from_solutions[i]);
    }

    // Swap back
    Moose::swapLibMeshComm(swapped);
  }
*/

  // We've found the nearest nodes for this processor.  We need to see which processor _actually_ found the nearest though
  _communicator.minloc(min_distances, min_procs);

  // Now loop through min_procs and see if _this_ processor had the actual minimum for any nodes.
  // If it did then we're going to go get the value from that nearest node and transfer its value
  processor_id_type proc_id = processor_id();

  for (unsigned int j=0; j<min_procs.size(); j++)
  {
    if (min_procs[j] == proc_id) // This means that this processor really did find the minimum so we need to transfer the value
    {
      // The zero only works for LAGRANGE!
      dof_id_type to_dof = 0;

      if (is_nodal)
      {
        Node & to_node = to_mesh->node(j);
        to_dof = to_node.dof_number(to_sys_num, to_var_num, 0);
      }
      else
      {
        Elem & to_elem = *to_mesh->elem(j);
        to_dof = to_elem.dof_number(to_sys_num, to_var_num, 0);
      }

      // The app that has the nearest node in it
      unsigned int from_app_num = min_apps[j];

      mooseAssert(_multi_app->hasLocalApp(from_app_num), "Something went very wrong!");

      FEProblem & from_problem = *_multi_app->appProblem(from_app_num);
      MooseVariable & from_var = from_problem.getVariable(0, _from_var_name);
      SystemBase & from_system_base = from_var.sys();

      System & from_sys = from_system_base.system();
      unsigned int from_sys_num = from_sys.number();

      unsigned int from_var_num = from_sys.variable_number(from_var.name());

      // EquationSystems & from_es = from_sys.get_equation_systems();

      MooseMesh * from_mesh = NULL;

      if (_displaced_source_mesh && from_problem.getDisplacedProblem())
        from_mesh = &from_problem.getDisplacedProblem()->mesh();
      else
        from_mesh = &from_problem.mesh();

      Node & from_node = from_mesh->node(min_nodes[j]);

      // Assuming LAGRANGE!
      dof_id_type from_dof = from_node.dof_number(from_sys_num, from_var_num, 0);
      Real from_value = (*from_sys.solution)(from_dof);

      to_solution.set(to_dof, from_value);
    }
  }

  to_solution.close();
  to_sys.update();
}

void
MultiAppNearestNodeTransfer::execute()
{
  _console << "Beginning NearestNodeTransfer " << _name << std::endl;

  getAppInfo();

  switch (_direction)
  {
    case TO_MULTIAPP:
      transferToMultiApp();
      break;

    case FROM_MULTIAPP:
      transferFromMultiApp();
      break;
  }

  _console << "Finished NearestNodeTransfer " << _name << std::endl;
}

Node *
MultiAppNearestNodeTransfer::getNearestNode(const Point & p, Real & distance, MooseMesh * mesh, bool local)
{
  distance = std::numeric_limits<Real>::max();
  Node * nearest = NULL;

  if (isParamValid("source_boundary"))
  {
    BoundaryID src_bnd_id = mesh->getBoundaryID(getParam<BoundaryName>("source_boundary"));

    ConstBndNodeRange & bnd_nodes = *mesh->getBoundaryNodeRange();
    for (ConstBndNodeRange::const_iterator nd = bnd_nodes.begin() ; nd != bnd_nodes.end(); ++nd)
    {
      const BndNode * bnode = *nd;
      if (bnode->_bnd_id == src_bnd_id)
      {
        Node * node = bnode->_node;
        Real current_distance = (p - *node).size();

        if (current_distance < distance)
        {
          distance = current_distance;
          nearest = node;
        }
      }
    }
  }
  else
  {
    MeshBase::const_node_iterator nodes_begin = local ? mesh->localNodesBegin() : mesh->getMesh().nodes_begin();
    MeshBase::const_node_iterator nodes_end   = local ? mesh->localNodesEnd()   : mesh->getMesh().nodes_end();

    for (MeshBase::const_node_iterator node_it = nodes_begin; node_it != nodes_end; ++node_it)
    {
      Real current_distance = (p - *(*node_it)).size();

      if (current_distance < distance)
      {
        distance = current_distance;
        nearest = *node_it;
      }
    }
  }

  return nearest;
}

Real
MultiAppNearestNodeTransfer::bboxMaxDistance(Point p, MeshTools::BoundingBox bbox)
{
  std::vector<Point> source_points(2);
  source_points[0] = bbox.first;
  source_points[1] = bbox.second;

  std::vector<Point> all_points(8);
  for (unsigned int x = 0; x < 2; x++)
  {
    for (unsigned int y = 0; y < 2; y++)
    {
      for (unsigned int z = 0; z < 2; z++)
      {
        all_points[x + 2*y + 4*z] = Point(source_points[x](0), source_points[y](1), source_points[z](2));
      }
    }
  }

  Real max_distance = 0.;

  for (unsigned int i = 0; i < 8; i++)
  {
    Real distance = (p - all_points[i]).size();
    if (distance > max_distance)
      max_distance = distance;
  }
  return max_distance;
}

Real
MultiAppNearestNodeTransfer::bboxMinDistance(Point p, MeshTools::BoundingBox bbox)
{
  std::vector<Point> source_points(2);
  source_points[0] = bbox.first;
  source_points[1] = bbox.second;

  std::vector<Point> all_points(8);
  for (unsigned int x = 0; x < 2; x++)
  {
    for (unsigned int y = 0; y < 2; y++)
    {
      for (unsigned int z = 0; z < 2; z++)
      {
        all_points[x + 2*y + 4*z] = Point(source_points[x](0), source_points[y](1), source_points[z](2));
      }
    }
  }

  Real min_distance = 0.;

  for (unsigned int i = 0; i < 8; i++)
  {
    Real distance = (p - all_points[i]).size();
    if (distance < min_distance)
      min_distance = distance;
  }
  return min_distance;
}
